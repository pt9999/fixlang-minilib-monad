module ResultTest;

import Minilib.Common.IORef;
import Minilib.Monad.Result;
import Minilib.Monad.Trans;
import Minilib.Monad.Error;
import Minilib.Monad.IO;
import Minilib.Monad.State;
import Minilib.Trait.Traversable;
//import Minilib.Text.StringEx;
import Minilib.Testing.UnitTest;

test_map_result_t: TestCase;
test_map_result_t = (
    make_test("test_map_result_t") $ |_|
    let f: IO (Result CInt I64) -> IOFail (Result String U64) = |io| (
        pure $ match *io.lift {
            ok(i64) => ok(i64.to_U64),
            err(cint) => err("err: errcode=" + cint.to_string),
        }
    );
    let res: ResultT CInt IO I64 = result_t $ pure $ ok(42);
    let res: ResultT ErrMsg IOFail U64 = res.map_result_t(f);
    let actual = *res.run_result_t;
    assert_equal("eq", ok(42_U64), actual);;
    let res: ResultT CInt IO I64 = result_t $ pure $ err(-2.to_CInt);
    let res: ResultT ErrMsg IOFail U64 = res.map_result_t(f);
    let actual = *res.run_result_t;
    assert_equal("eq", err("err: errcode=-2"), actual);;
    pure()
);

test_from_iofail: TestCase;
test_from_iofail = (
    make_test("test_from_iofail") $ |_|
    let iof: IOFail I64 = pure(42);
    let actual = *ResultT::from_iofail(iof).run_result_t.lift;
    assert_equal("eq", ok(42), actual);;
    let iof: IOFail I64 = throw $ "err";
    let actual = *ResultT::from_iofail(iof).run_result_t.lift;
    assert_equal("eq", err("err"), actual)
);

test_to_iofail: TestCase;
test_to_iofail = (
    make_test("test_to_iofail") $ |_|
    let res: ResultT ErrMsg IO I64 = result_t $ pure $ ok(42);
    let iof: IOFail I64 = res.to_iofail;
    let actual = *iof.to_result.lift;
    assert_equal("eq", ok(42), actual);;
    let res: ResultT ErrMsg IO I64 = result_t $ pure $ err("err");
    let iof: IOFail I64 = res.to_iofail;
    let actual = *iof.to_result.lift;
    assert_equal("eq", err("err"), actual)
);

test_functor: TestCase;
test_functor = (
    make_test("test_functor") $ |_|
    let rma: ResultT (Array ErrMsg) Option I64 = result_t $ some $ ok $ 42;
    let rma2 = rma.map(to_string);
    assert_equal("eq", some $ ok $ "42", rma2.run_result_t);;

    let rma: ResultT (Array ErrMsg) Option I64 = result_t $ some $ err $ ["err1", "err2"];
    let rma2 = rma.map(to_string);
    assert_equal("eq", some $ err $ ["err1", "err2"], rma2.run_result_t);;

    let rma: ResultT (Array ErrMsg) Option I64 = result_t $ none();
    let rma2 = rma.map(to_string);
    assert_equal("eq", none(), rma2.run_result_t);;

    pure()
);

test_pure: TestCase;
test_pure = (
    make_test("test_pure") $ |_|
    let rma: ResultT ErrMsg Option I64 = pure(42);
    assert_equal("eq", some $ ok $ 42, rma.run_result_t)
);

test_bind: TestCase;
test_bind = (
    make_test("test_bind") $ |_|
    // an `err()` or `none()` in `rma` has priority over `rma2`
    let rma: ResultT ErrMsg Option I64 = result_t $ some $ ok(42);
    let rma2: ResultT ErrMsg Option String = rma.bind(|i| result_t $ some $ ok $ "a" + i.to_string);
    assert_equal("eq", some $ ok $ "a42", rma2.run_result_t);;
    let rma2: ResultT ErrMsg Option String = rma.bind(|i| result_t $ some $ err("err"));
    assert_equal("eq", some $ err $ "err", rma2.run_result_t);;
    let rma2: ResultT ErrMsg Option String = rma.bind(|i| result_t $ none());
    assert_equal("eq", none(), rma2.run_result_t);;

    let rma: ResultT ErrMsg Option I64 = result_t $ some $ err("err0");
    let rma2: ResultT ErrMsg Option String = rma.bind(|i| result_t $ some $ ok $ "a" + i.to_string);
    assert_equal("eq", some $ err $ "err0", rma2.run_result_t);;
    let rma2: ResultT ErrMsg Option String = rma.bind(|i| result_t $ some $ err("err"));
    assert_equal("eq", some $ err $ "err0", rma2.run_result_t);;
    let rma2: ResultT ErrMsg Option String = rma.bind(|i| result_t $ none());
    assert_equal("eq", some $ err $ "err0", rma2.run_result_t);;

    let rma: ResultT ErrMsg Option I64 = result_t $ none();
    let rma2: ResultT ErrMsg Option String = rma.bind(|i| result_t $ some $ ok $ "a" + i.to_string);
    assert_equal("eq", none(), rma2.run_result_t);;
    let rma2: ResultT ErrMsg Option String = rma.bind(|i| result_t $ some $ err("err"));
    assert_equal("eq", none(), rma2.run_result_t);;
    let rma2: ResultT ErrMsg Option String = rma.bind(|i| result_t $ none());
    assert_equal("eq", none(), rma2.run_result_t);;
    pure()
);

test_lift_t: TestCase;
test_lift_t = (
    make_test("test_lift_t") $ |_|
    let rma: ResultT ErrMsg Option I64 = lift_t $ some(42);
    assert_equal("eq", some $ ok $ 42, rma.run_result_t);;
    let rma: ResultT ErrMsg Option I64 = lift_t $ none();
    assert_equal("eq", none(), rma.run_result_t);;
    pure()
);

test_lift_t_array: TestCase;
test_lift_t_array = (
    make_test("test_lift_t_array") $ |_|
    let rma: ResultT ErrMsg Array I64 = do {
        let a = *[1, 2, 3].lift_t;
        let b = *[10, 20].lift_t;
        let c = a + b;
        if c % 2 == 0 { error $ "error" + c.to_string };
        pure $ c
    };
    let expected = [ok(11), ok(21), err("error12"), err("error22"), ok(13), ok(23)];
    let actual = rma.run_result_t;
    assert_equal("eq", expected, actual)
);

test_error: TestCase;
test_error = (
    make_test("test_error") $ |_|
    let rma: ResultT ErrMsg Option I64 = error $ "err";
    assert_equal("eq", some $ err $ "err", rma.run_result_t)
);

test_catch: TestCase;
test_catch = (
    make_test("test_catch") $ |_|
    let check_number: I64 -> ResultT ErrMsg IOFail String = |i| (
        if i == 0 { pure("pure") };
        if i == 1 { error("error") };
        if i == 2 { lift_t $ (throw("throw") : IOFail String) };
        pure $ "undefined"
    );
    let get_result: I64 -> IOFail String = |i| (
        let rma: ResultT ErrMsg IOFail String = check_number(i).catch(
            |err| pure $ "catch:" + err
        );
        let iof: IOFail (Result ErrMsg String) = rma.run_result_t;
        let io: IO String = iof.map(to_string).try(|errmsg| pure $ "try:" + errmsg);
        io.lift
    );

    assert_equal("pattern0", "ok(pure)", *get_result(0));;
    assert_equal("pattern1", "ok(catch:error)", *get_result(1));;
    assert_equal("pattern2", "try:throw", *get_result(2));;
    pure()
);

test_lift_io: TestCase;
test_lift_io = (
    make_test("test_lift_io") $ |_|
    let rma: ResultT ErrMsg IOFail I64 = do {
        lift_io $ println("message from test_lift_io");;
        let a = *(result_t $ pure $ err("err"));
        lift_io $ println("this message will not be printed");;
        pure(a + 1)
    };
    assert_equal("eq", ok $ err $ "err", *rma.run_result_t.to_result.lift)
);

test_lift_iofail: TestCase;
test_lift_iofail = (
    make_test("test_lift_io") $ |_|
    let rma: ResultT ErrMsg IOFail I64 = do {
        lift_io $ println("message from test_lift_iofail");;
        let a = *(lift_iofail $ throw("err"));
        lift_io $ println("this message will not be printed");;
        pure(a + 1)
    };
    // Before 0.10.0, `actual` was `err $ "err"`.
    // That is, the error was hold in the `IOFail` monad, not `ResultT` monad.
    // Now the error is hold in the `ResultT` monad.
    //let expected: Result ErrMsg (Result ErrMsg I64) = err $ "err";    // before 0.10.0
    let expected: Result ErrMsg (Result ErrMsg I64) = ok $ err $ "err"; // 0.10.0 and after
    let actual: Result ErrMsg (Result ErrMsg I64) = *rma.run_result_t.to_result.lift;
    assert_equal("eq", expected, actual)
);

// `ResultT ErrMsg (StateT s IO)` will not lost the state even if an error occurs.
// On the other hand, `StateT s IOFail` will lost the state when an error occurs.
test_result_state_io: TestCase;
test_result_state_io = (
    make_test("test_result_state_io") $ |_|
    let logger: IORef String = *IORef::make("");
    let rma: I64 -> ResultT ErrMsg (StateT String IO) I64 = |input| do {
        lift_io $ logger.put("");;
        lift_io $ logger.mod(concat("message1;"));;
        lift_t $ put_state("state1");;
        if input < 10 { lift_iofail $ throw("input < 10") };
        lift_io $ logger.mod(concat("message2;"));;
        lift_t $ put_state("state2");;
        if input < 20 { error("input < 20") };
        lift_io $ logger.mod(concat("message3;"));;
        lift_t $ put_state("state3");;
        pure(input + 1)
    };
    assert_equal("eq", ("state1", err $ "input < 10"), *rma(5).run_result_t.run_state_t("").lift);;
    assert_equal("eq", "message1;", *logger.get);;

    assert_equal("eq", ("state2", err $ "input < 20"), *rma(15).run_result_t.run_state_t("").lift);;
    assert_equal("eq", "message1;message2;", *logger.get);;

    assert_equal("eq", ("state3", ok $ 26), *rma(25).run_result_t.run_state_t("").lift);;
    assert_equal("eq", "message1;message2;message3;", *logger.get);;
    pure()
);

main: IO ();
main = (
    [
        test_map_result_t,
        test_from_iofail,
        test_to_iofail,
        test_functor,
        test_pure,
        test_bind,
        test_lift_t,
        test_lift_t_array,
        test_error,
        test_catch,
        test_lift_io,
        test_lift_iofail,
        test_result_state_io,
    ]
    .run_test_driver
);
