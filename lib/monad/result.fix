// A monad transformer that wraps `m (Result e a)`.
module Minilib.Monad.Result;

import Minilib.Monad.Trans;
import Minilib.Monad.Error;
import Minilib.Monad.Reader;
import Minilib.Monad.State;
import Minilib.Monad.IO;

// A monad transformer that wraps `m (Result e a)`.
// This represents an operation result (success or error).
// `e` is a type of an error if the operation fails.
// `m` is a type of an underlying monad.
// `a` is a type of an operation result if operation is successful.
type [m: *->*] ResultT e m a = unbox struct {
    data: m (Result e a)
};

// Creates a ResultT monad from an operation result.
result_t: [m: *->*] m (Result e a) -> ResultT e m a;
result_t = |ma| ResultT { data: ma };

// Gets the operation result.
run_result_t: [m: *->*] ResultT e m a -> m (Result e a);
run_result_t = @data;

// Maps a ResultT monad with the specified function.
map_result_t: [m: *->*, m2: *->*] (m (Result e a) -> m2 (Result e2 a2)) -> ResultT e m a -> ResultT e2 m2 a2;
map_result_t = |f, ma| result_t $ f $ ma.run_result_t;

namespace ResultT {
    // Converts an `IOFail` monad to a `ResultT ErrMsg IO` monad.
    from_iofail: IOFail a -> ResultT ErrMsg IO a;
    from_iofail = |iof| (
        result_t $ iof.to_result
    );

    // Converts a `ResultT ErrMsg IO` monad to an `IOFail` monad.
    to_iofail: ResultT ErrMsg IO a -> IOFail a;
    to_iofail = |res| (
        from_io_result $ res.run_result_t
    );
}

impl [m: Functor] ResultT e m: Functor {
    map = |f, rma| result_t $ (
        rma.run_result_t.map(map(f))
    );
}

impl [m: Monad] ResultT e m: Monad {
    pure = |a| result_t $ pure $ pure $ a;
    bind = |f, rma| result_t $ do {
        let res = *rma.run_result_t;
        if res.is_err { pure $ err(res.as_err) };
        let emb = f(res.as_ok);
        emb.run_result_t
    };
}

impl ResultT e: MonadTrans {
    lift_t = |ma| result_t $ ma.bind(ok >> pure);
}

impl [m: Monad] ResultT ErrMsg m: MonadErrorIF {
    error = |e| result_t $ pure $ err(e);
    catch = |handler, rma| (
        result_t $ do {
            let res = *rma.run_result_t;
            if res.is_ok { pure $ res };
            handler(res.as_err).run_result_t
        }
    );
}

impl [m: MonadIO] ResultT e m: MonadIOIF {
    lift_io = lift_t << lift_io;
}

// Implementation of `MonadIOFailIF`.
//
// NOTE: If `lift_iofail` is called and the lifted `IOFail` monad raises an error,
// the error is recorded in the `ResultT` monad, not the underlying monad.
//
// The reason for this behavior change is to ensure that `ResultT ErrMsg (StateT s m)`
// will not lose state even if an error occurs.
impl [m: MonadIO] ResultT ErrMsg m: MonadIOFailIF {
    lift_iofail = |iof| (
        result_t $ do {
            iof.to_result.lift_io
        }
    );
}

impl [m: MonadReader] ResultT e m: MonadReaderIF {
    type EnvType (ResultT e m) = EnvType m;
    ask = ask.lift_t;
    local = |f, ma| ma.run_result_t.local(f).result_t;
}

impl [m: MonadState] ResultT e m: MonadStateIF {
    type StateType (ResultT e m) = StateType m;
    get_state = get_state.lift_t;
    put_state = put_state >> lift_t;
    mod_state_ = mod_state_ >> lift_t;
}
