// State Monad which maintains a mutable state.
//
// Example:
// ```
// main: IO () = (
//     let sm: StateT String IO () = do {
//         let str = *get_state;
//         println(str).lift_io;;    // will print "hello"
//         put_state("world")
//     };
//     let (str, ()) = *sm.run_state_t("hello");
//     assert_eq(|_| "str", "world", str)
// );
// ```
module Minilib.Monad.State;

import Minilib.Functor.Pair;
import Minilib.Monad.Iden;
import Minilib.Monad.Trans;
import Minilib.Monad.Error;
import Minilib.Monad.IO;

// A trait for the interface of generic state monads.
trait MonadState = Monad + MonadStateIF;

// A trait for generic state monads that manages the internal state.
trait [sm: * -> *] sm: MonadStateIF {
    // The type of the internal state.
    type StateType sm;
    // A monad that returns the internal state as a value.
    get_state: sm (StateType sm);
    // A monad that puts the specified value to the internal state.
    put_state: (StateType sm) -> sm ();
    // A monad that modifies the current state with the specified function.
    mod_state_: (StateType sm -> StateType sm) -> sm ();
}

// A monad that modifies the current state with the specified function.
mod_state: [sm: MonadState] (StateType sm -> StateType sm) -> sm ();
mod_state = mod_state_;

// NOTE: The old implementation of `mod_state` had a bug that prevented the state from being unique.
// ```
// mod_state = |f| put_state $ f $ *get_state;
// ```
// NOTE: For backward compatibility, `mod_state` should be accessible as `State::mod_state`.

// `gets(f)` is same as `get_state.map(f)`.
gets: [sm: MonadState] (StateType sm -> a) -> sm a;
gets = |f| get_state.bind(f >> pure);

//------------------------------------------------------------------------

// State monad wraps a function from a initial state to a pair of a value and a final state.
type [m: *->*] StateT s m a = unbox struct {
    data: s -> m (s, a)
};

type State s = StateT s Iden;

// Creates a StateT monad from a function.
make_state_t_monad: [m: Monad] (s -> m (s, a)) -> StateT s m a;
make_state_t_monad = |f| StateT { data: f };

// Synonym of `make_state_t_monad`.
state_t: [m: Monad] (s -> m (s, a)) -> StateT s m a;
state_t = make_state_t_monad;

// Creates a State monad from a function.
make_state_monad: (s -> (s, a)) -> State s a;
make_state_monad = |f| make_state_t_monad(f >> pure);

// Synonym of `make_state_monad`.
state: (s -> (s, a)) -> State s a;
state = make_state_monad;

// Runs a StateT monad with the supplied initial state.
//
// Example:
// ```
//     let sm: StateT String IO I64 = do {
//         State::mod_state(concat(" world"));;
//         pure $ 42
//     };
//     let (str, i64) = *sm.run_state_t("hello");  // returns ("hello world", 42)
// ```
run_state_t: [m: Monad] s -> StateT s m a -> m (s, a);
run_state_t = |s, ma| (ma.@data)(s);

// Runs a State monad with the supplied initial state.
run_state: s -> State s a -> (s, a);
run_state = |s, ma| ma.run_state_t(s).get;

// Runs a StateT monad with the supplied initial state and return the final value, discarding the final state.
//
// Example:
// ```
//     let sm: StateT I64 IO String = do {
//         State::mod_state(add(22));;
//         pure $ (*get_state).to_string
//     };
//     let str = *sm.eval_state_t(20);  // returns "42"
// ```
eval_state_t: [m: Monad] s -> StateT s m a -> m a;
eval_state_t = |s, ma| (
    let (s, a) = *ma.run_state_t(s);
    pure $ a
);

// Runs a State monad with the supplied initial state and return the final value, discarding the final state.
eval_state: s -> State s a -> a;
eval_state = |s, ma| ma.eval_state_t(s).get;

// Runs a StateT monad with the supplied initial state and return the final state, discarding the final value.
//
// Example:
// ```
//     let sm: StateT String IO () = do {
//         State::mod_state(concat(" world"));;
//         pure $ ()
//     };
//     let str = *sm.exec_state_t("hello");  // returns "hello world"
// ```
exec_state_t: [m: Monad] s -> StateT s m a -> m s;
exec_state_t = |s, ma| (
    let (s, a) = *ma.run_state_t(s);
    pure $ s
);

// Runs a State monad with the supplied initial state and return the final state, discarding the final value.
exec_state: s -> State s a -> s;
exec_state = |s, ma| ma.exec_state_t(s).get;

// Maps both the return value and final state.
map_state_t: [m: Monad, n: Monad] (m (s, a) -> n (s, b)) -> StateT s m a -> StateT s n b;
map_state_t = |f, ma| (
    make_state_t_monad $ (ma.@data) >> f
);

impl [m: Monad] StateT s m: Functor {
    map = |f, ma| make_state_t_monad $ |s| (
        let (ss, a) = *ma.run_state_t(s);
        pure $ (ss, f(a))
    );
}

impl [m: Monad] StateT s m: Monad
{
    pure = |a| StateT { data: |s| pure((s, a)) };
    bind = |f, ma| StateT { data: |s|
        let (s, a) = *ma.run_state_t(s);
        f(a).run_state_t(s)
    };
}

impl [m: Monad] StateT s m: MonadStateIF {
    type StateType (StateT s m) = s;
    get_state = make_state_t_monad $ |s| pure $ (s, s);
    put_state = |s| make_state_t_monad $ |_| pure $ (s, ());
    mod_state_ = |f| make_state_t_monad $ |s| pure $ (f(s), ());
}

impl StateT s: MonadTrans {
    lift_t = |ma| (
        make_state_t_monad $ |s|
        let a = *ma;
        pure $ (s, a)
    );
}

impl [m: MonadError] StateT s m: MonadErrorIF {
    error = lift_t << error;
    catch = |handler, sma| (
        make_state_t_monad $ |s|
        sma.run_state_t(s).catch(
            handler >> run_state_t(s)
        )
    );
}

impl [m: MonadIO] StateT s m: MonadIOIF {
    lift_io = lift_t << lift_io;
}

impl [m: MonadIOFail] StateT s m: MonadIOFailIF {
    lift_iofail = lift_t << lift_iofail;
}

// Transforms a state monad with a lens action.
//
// For example, if `Foo` has a field `bar: Bar`, then `act_bar` is a function of type
// `[f: Functor] (Bar -> f Bar) -> (Foo -> f Foo)`.
// Using `act_bar`, a state monad of `Bar` can be transformed to a state monad of `Foo`.
//
// Note that `act_xxx` can be composed, for example `Foo::act_bar << Bar::act_baz << Baz::act_qux`.
//
// Example:
// ```
// change_bar: StateT Bar IO ();
// change_bar = ...;
// change_foo: StateT Foo IO ();
// change_foo = change_bar.lens_state_t(Foo::act_bar);
// ```
lens_state_t: [m: Monad, m: Functor] ((s -> PairLT a m s) -> (t -> PairLT a m t)) -> StateT s m a -> StateT t m a;
lens_state_t = |act, sma| (
    let f: s -> m (s, a) = sma.@data;
    let f: s -> PairLT a m s = f >> PairLT::make;
    let f: t -> PairLT a m t = act(f);
    let f: t -> m (t, a) = f >> PairLT::get;
    make_state_t_monad(f)
);

lens_state: ((s -> PairLT a Iden s) -> (t -> PairLT a Iden t)) -> State s a -> State t a;
lens_state = lens_state_t;

// A variable bound to a substate of the State monad.
// You can get, set, and modify the bound substate.
// This is similar to `AsyncTask::Var`, but the result of each operation is a State monad, not an IO monad.
//
// Example:
// ```
// type S = unbox struct { a: I64 };
//
// main: IO ();
// main = (
//    eval_state_t(S{ a: 123 }) $ do {
//      let v = SVar::make(|s| s[^a]);
//      let a = *v.get;
//      println("a=" + a.to_string).lift_io;;
//      v.SVar::set(456);;
//      println("a=" + (*v.get).to_string).lift_io;;
//      v.mod(|a| a + 78);;
//      println("a=" + (*v.get).to_string).lift_io
//    }
// );
// ```
type SVar s a = unbox struct {
    data: s -> (a -> Result a a) -> Result a s
};

namespace SVar {
    // A variable bound to the whole state.
    whole_state: SVar s s;
    whole_state = SVar::make(|s, f| f(s));

    // Create a variable bound to a substate.
    //
    // Example:
    // ```
    // let svar = SVar::make(|s| s[^a]);
    // ```
    // # Parameters
    // - `f` - A function from a state to the store of a substate.
    make: (s -> (a -> Result a a) -> Result a s) -> SVar s a;
    make = |f| SVar { data: f };

    // Get the substate from a variable.
    //
    // Example:
    // ```
    // let a = *svar.get;
    // ```
    // # Parameters
    // - `svar` - A variable
    get: [m: MonadState, StateType m = s] SVar s a -> m a;
    get = |svar| (
        let s = *get_state;
        let store = (svar.@data)(s);
        // uses `err` as a const functor
        let sfa = store(|a| err(a));
        pure $ sfa.as_err
    );

    // Set the substate to a variable.
    //
    // Example:
    // ```
    // svar.SVar::set(123);;
    // ```
    // # Parameters
    // - `val` - A value to set
    // - `svar` - A variable
    set: [m: MonadState, StateType m = s] a -> SVar s a -> m ();
    set = |val, svar| (
        mod_state_(|s|
            let store = (svar.@data)(s);
            // uses `ok` as an identity functor
            let sfs = store(|a0| ok(val));
            sfs.as_ok
        )
    );

    // Modify the substate using a variable.
    //
    // Example:
    // ```
    // svar.mod(|val| val + 123);;
    // ```
    // # Parameters
    // - `f` - A function to modify the substate
    // - `svar` - A variable
    mod: [m: MonadState, StateType m = s] (a -> a) -> SVar s a -> m ();
    mod = |f, svar| (
        mod_state_(|s|
            let store = (svar.@data)(s);
            // uses `ok` as an identity functor
            let sfs = store(|a| ok(f(a)));
            sfs.as_ok
        )
    );
}
